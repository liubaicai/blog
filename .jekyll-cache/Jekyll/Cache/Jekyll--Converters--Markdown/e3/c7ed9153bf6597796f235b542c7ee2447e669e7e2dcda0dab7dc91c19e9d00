I"$<pre class="brush:cpp;">
void CCScheduler::update(float dt)
{
&nbsp;&nbsp;&nbsp; m_bUpdateHashLocked = true;

&nbsp;// é¢„å¤„ç†
&nbsp;&nbsp;&nbsp; if (m_fTimeScale != 1.0f)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dt *= m_fTimeScale;
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; // æšä¸¾æ‰€æœ‰çš„updateå®šæ—¶å™¨
&nbsp;&nbsp;&nbsp; tListEntry *pEntry, *pTmp;

&nbsp;&nbsp;&nbsp; CCScriptEngineProtocol* pEngine = CCScriptEngineManager::sharedManager()-&gt;getScriptEngine();

&nbsp;&nbsp;&nbsp; // ä¼˜å…ˆçº§å°äº0çš„å®šæ—¶å™¨
&nbsp;&nbsp;&nbsp; DL_FOREACH_SAFE(m_pUpdatesNegList, pEntry, pTmp)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((! pEntry-&gt;paused) &amp;&amp; (! pEntry-&gt;markedForDeletion))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pEngine != NULL &amp;&amp; kScriptTypeJavascript == pEngine-&gt;getScriptType())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pEngine-&gt;executeSchedule(0, dt, (CCNode *)pEntry-&gt;target);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pEntry-&gt;target-&gt;update(dt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; // ä¼˜å…ˆçº§ç­‰äº0çš„å®šæ—¶å™¨
&nbsp;&nbsp;&nbsp; DL_FOREACH_SAFE(m_pUpdates0List, pEntry, pTmp)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((! pEntry-&gt;paused) &amp;&amp; (! pEntry-&gt;markedForDeletion))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pEngine != NULL &amp;&amp; kScriptTypeJavascript == pEngine-&gt;getScriptType())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pEngine-&gt;executeSchedule(0, dt, (CCNode *)pEntry-&gt;target);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pEntry-&gt;target-&gt;update(dt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; // ä¼˜å…ˆçº§å¤§äº0çš„å®šæ—¶å™¨
&nbsp;&nbsp;&nbsp; DL_FOREACH_SAFE(m_pUpdatesPosList, pEntry, pTmp)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((! pEntry-&gt;paused) &amp;&amp; (! pEntry-&gt;markedForDeletion))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pEngine != NULL &amp;&amp; kScriptTypeJavascript == pEngine-&gt;getScriptType())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pEngine-&gt;executeSchedule(0, dt, (CCNode *)pEntry-&gt;target);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pEntry-&gt;target-&gt;update(dt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; // æšä¸¾æ‰€æœ‰çš„æ™®é€šå®šæ—¶å™¨
&nbsp;&nbsp;&nbsp; for (tHashTimerEntry *elt = m_pHashForTimers; elt != NULL; )
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pCurrentTarget = elt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_bCurrentTargetSalvaged = false;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (! m_pCurrentTarget-&gt;paused)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;//æšä¸¾æ­¤èŠ‚ç‚¹ä¸­çš„è®¡æ—¶å™¨
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // timersæ•°ç»„å¯èƒ½åœ¨å¾ªç¯ä¸­æ”¹å˜&nbsp; éœ€è¦æ ¼å¤–å°å¿ƒ
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (elt-&gt;timerIndex = 0; elt-&gt;timerIndex &lt; elt-&gt;timers-&gt;num; ++(elt-&gt;timerIndex))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elt-&gt;currentTimer = (CCTimer*)(elt-&gt;timers-&gt;arr[elt-&gt;timerIndex]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elt-&gt;currentTimerSalvaged = false;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elt-&gt;currentTimer-&gt;update(dt);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (elt-&gt;currentTimerSalvaged)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // The currentTimer told the remove itself. To prevent the timer from
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // accidentally deallocating itself before finishing its step, we retained
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // it. Now that step is done, it&#39;s safe to release it.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elt-&gt;currentTimer-&gt;release();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elt-&gt;currentTimer = NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // elt, at this moment, is still valid
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // so it is safe to ask this here (issue #490)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elt = (tHashTimerEntry *)elt-&gt;hh.next;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // only delete currentTarget if no actions were scheduled during the cycle (issue #481)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_bCurrentTargetSalvaged &amp;&amp; m_pCurrentTarget-&gt;timers-&gt;num == 0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; removeHashElement(m_pCurrentTarget);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; // å¤„ç†è„šæœ¬å¼•æ“çš„ç›¸å…³äº‹å®œ
&nbsp;&nbsp;&nbsp; if (m_pScriptHandlerEntries)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = m_pScriptHandlerEntries-&gt;count() - 1; i &gt;= 0; i--)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CCSchedulerScriptHandlerEntry* pEntry = static_cast&lt;CCSchedulerScriptHandlerEntry*&gt;(m_pScriptHandlerEntries-&gt;objectAtIndex(i));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pEntry-&gt;isMarkedForDeletion())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_pScriptHandlerEntries-&gt;removeObjectAtIndex(i);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else if (!pEntry-&gt;isPaused())
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pEntry-&gt;getTimer()-&gt;update(dt);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; // æ¸…ç†æ‰€æœ‰çš„è¢«æ ‡è®°äº†åˆ é™¤è®°å·çš„updateæ–¹æ³•
&nbsp;&nbsp;&nbsp; // ä¼˜å…ˆçº§å°äº0çš„å®šæ—¶å™¨
&nbsp;&nbsp;&nbsp; DL_FOREACH_SAFE(m_pUpdatesNegList, pEntry, pTmp)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pEntry-&gt;markedForDeletion)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;removeUpdateFromHash(pEntry);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; // ä¼˜å…ˆçº§ç­‰äº0çš„å®šæ—¶å™¨
&nbsp;&nbsp;&nbsp; DL_FOREACH_SAFE(m_pUpdates0List, pEntry, pTmp)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pEntry-&gt;markedForDeletion)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;removeUpdateFromHash(pEntry);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; // ä¼˜å…ˆçº§å¤§äº0çš„å®šæ—¶å™¨
&nbsp;&nbsp;&nbsp; DL_FOREACH_SAFE(m_pUpdatesPosList, pEntry, pTmp)
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (pEntry-&gt;markedForDeletion)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this-&gt;removeUpdateFromHash(pEntry);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; m_bUpdateHashLocked = false;

&nbsp;&nbsp;&nbsp; m_pCurrentTarget = NULL;
}</pre>

<p>
	&nbsp;
</p>
:ET